# Frontend StyleGuide and Coding Conventions

Единообразие существенно снижает когнитивную сложность восприятия кода.
Все наши проекты должны быть в одном стиле во всем - наименование, структура и тд.
Единообразие и следование правилам важнее чем то, что гласят отдельные правила.

За основу берем [конфиг от typescript book](https://github.com/basarat/typescript-book/blob/master/docs/styleguide/styleguide.md).

Стараемся большую часть работы по проверки качества кода свалить на софт. Люди ошибаются постоянно, компьютеры - никогда.
Поэтому eslint, prettier, etc - наше все.

## Linting

### [eslint-config-bestdoctor](https://github.com/best-doctor/eslint-config-bestdoctor)
используем во всех проектах, при необходимости добавляем специфичные для проекта правила/плагины (например штуки про react-native для мобилки).

Если проект не полностью соответствует конфигу из-за легаси - временно переводим сломанные правила в `warn`.
По мере рефакторинга все должно быть поправлено и все исключения убраны.

Отключение правила линтинга имеет исключительный характер и должно производиться точечно (для строки), сопровождаться комментарием о причинах отключения и, в идеальном мире, сопровождаться ссылкой на таску на починку

## Formatting

За него отвечает prettier с такими вот настройками:

```json
{
  "printWidth": 120,
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

## Project structure

### Общие положения

Мы используем компонентный подход и пытаемся сделать структуру проекта максимально модульной.

В `src` проекта находятся/могут находиться папки:

- `entities` - корневая директория содержащая код относящийся к бизнес-сущностям
  + `[Имя_сущности]` - корневая директория для конкретной бизнес-сущности (e.g. `User`)
    * `components` - компоненты отвечающие за view слой сущности;
    * `contexts` - контексты используются **только** в случае необходимости глобального использования сущности для избегания пропс-дриллинга, директория содержит всё относящееся к контекстам;
    * `hooks` - хуки сущности, содержит базовые хуки для работы с api (`queries`, `mutations`) и хуки специфичные для сущности. Инвалидаторы и фабрика ключей кэша запросов также находятся здесь;
    * `pages` - компоненты отвечающие за отображение страниц, относящихся к сущности.
- `features` - корневая директория для кода не относящегося к конкретной бизнес сущности, содержит в себе директории фичей, структуры, которых идентичны структуре в `entities`. Примеры фичей: 
  * `auth` - всё, что связано с авторизацией - хуки, компоненты вывода информации об пользователе, страница с ошибкой о недостатке прав;
  * `text` - функции плюрализации, компоненты вывода заголовков, абзацев и т.д.
  * `forms` - компоненты для создания форм (поля ввода, выпадающие списки и т.д.), хуки хранения значения форм 
- `typings` - общие для приложения типы данных, которые нельзя отнести к какой-то бизнес сущности (e.g. типизация модуля не имеющего нормальной типизации).
- `utils` - вспомогательные функции, которые шарятся между многими компонентами. У папки есть тенденция превращения в помойку, нужно стараться распределять функции между `entities` и `features`
- `constants` - статичные константы, например цвета, брейк поинты и тд. Если значение является вычисляемым - например ширина конечной области зависящая от размера экрана, это должно быть в `utils`. Аналогично `utils` имеет тенденцию превращения в помойку и нужно стараться избегать.

В корне проекта могут лежать базовые вещи типа инстанса истории браузера, роутер, тема визуализации, но лишь пока они атомарны, в случае наращивания функционала следует перенести в features

#### Реэкспорты
Индексные реэкспортирующие файлы по умолчанию - зло.
Допускаются только в директориях из которой по логике в большинстве случаев используется большая часть компонентов. Было бы хорошо иметь api к сущностям и фичам в виде индексных реэкспортов, но пока нет tree-shaking'а нормально обрабатывающего такие случаи - бандлы раздуваются и приложение затормаживается.
Также реэкспорты делают более сложным нахождение мёртвого кода (он тоже зло т.к. тратит время на сопровождение).

### Хранения данных и стейта
#### Работа с backend'ом
Для работы с бэкендом используется [react-query](https://www.npmjs.com/package/react-query)
Полезная статья по работе с ключами кэша: [Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys)
Фабрика генерации ключей:
```TypeScript
export function getRequestsKeys<TListKeys, TItemKeys = string>(entityName: string) {
  return {
    all: [entityName] as const,
    lists: [entityName, 'list'] as const,
    list: (keys: TListKeys) => [entityName, 'list', keys] as const,
    items: [entityName, 'item'] as const,
    item: (keys: TItemKeys) => [entityName, 'item', keys] as const,
  }
}
```

#### Стейт формы
Раздел в разработке

#### Глобальные стейты
По возможности избегаются. Всё что может быть локальным - делается локальным. Исключениями могут быть только вещи, которые действительно используются глобально - авторизация, стейт виджета, используемого на множестве страниц и т.д., для них допускается использование контекста.

### features и entities
#### Зачем все это надо
1. Разделение на фичи и сущности позволяет отделить бизнес-логику от общей
1. Модульная структура позволяет легко переиспользовать компоненты и шарить их между разными частями приложения или разными приложениями.
1. Разделение по сущностям способствует работе tree-shaking - чаще требуется несколько компонентов связанных отношением к одной сущности, а не внешне похожих

#### Размер файла

Чем меньше - тем лучше. Проще воспринимать 5 файлов по 100 строк чем один по 500. При этом разбивание должно быть
максимально логичным - выделяем обособленные куски и выносим их в component parts либо subcomponents.
Объемную логику выносим в utils.

## Names
### Общее

Название должно быть семантичным бизнес логике, то есть обозначать то, чем занимается данная сущность.
Например, компонент для переключения видимости пароля может называться `TogglePasswordVisibilityButton`.
И не может `EyeIconButton`.
Потому что:

1. Не понятно что именно делает данный элемент.
1. Название зависит от контента/стилей, если вместо картинки с глазом появится картинка с камерой, например, нужно переименовывать компонент.

Понятность названия важнее длины, красоты и грамматической правильности.

### Конкретное

#### Функции
Название функции всегда начинается глаголом.

- get\* - возвращает используемое значение.
- validate*, check* - возвращает bool.
- format\* - преобразовывает данные.
- set\* - устанавливает значение в стейте/сторе.
- handle\*(Change/Click/Press) - для функций оберток над set передаваемых в пропсы.
  
Исключение - функциональные пропсы компонентов начинаются на on\*, для отделения их от функций созданных в компоненте и консистентности со стандартными html-пропсами

#### Переменные
Переменная всегда существительное.

#### Флаги
Boolean - с префиксами is, has, can, has, have, was etc.

#### Коллекции
Коллекции - множественное число, например errors.

Про коллекции свойств:

- usersPhoneNumbers - номера телефонов юзеров
- userPhoneNumbers - номера телефонов юзера
- usersPhoneNumber - номер телефона юзеров?

Количество сущностей - постфикс Number

Число обозначающее порядковый номер - постфикс Index

Постфикс data - чтобы отличать данные с формы от объекта (например с бека).

Действие не должно смешиваться со состоянием - on-off, closed-open.

## Важные вещи

### Понятность

Код пишется один раз, а читается многократно. Понятность - важнейшее качество кода, важнее красоты, элегантности,
микрооптимизации и тд. Код должен быть прост и очевиден.

### Single responsibility

Одна функция выполняет одну задачу, но делает это хорошо.

- Если в названии функции есть and - возможно она слишком много на себя берет и ее нужно разделить?
- Если функция принимает boolean параметр, возможно он переключает ее поведение и ее нужно разделить?
- Если функция в несколько сотен строк кода, возможно стоит вычленить часть логики в другие функции?

#### Параметры функции

Если параметров один или два то можно передавать обычно ( `function foo(a: number, b: number)` ), иначе оборачиваются в объект ( `function foo({ a: number, b: number, c: string })` ).

#### Композиция функций

Как правило, если функция принимает слишком много параметров - нужно ее разбивать. Исключения - функции не содержащие логику в себе, например для передаче кучи полей на бек в одном запросе и тд. При этом функция может содержать асинхронный код который должен выполниться в момент ее вызова. То есть мы не можем заранее получить какой-то фрагмент готовых данных и просто передать его в эту функцию. В данном случае можно добавить в функцию стандартные аргументы onSuccess и onError, принимающие или не принимающие результаты выполнения функции в зависимости от необходимости.

### Комментарии

Комментарии - зло. Они могут устаревать, если их забыли поправить после изменения логики, они могут быть неверными, они могут быть слишком очевидными или недостаточно детальными. Самодокументируемый код - наше все. Если по коду функции не понятно что там происходит - значит это плохой нейминг функции и переменных.

Возможно стоит разбить логику на части и вынести их в функции с понятными названиями?
Даже если функция изначально была небольшой - это увеличит понятность.

Исключения - комментарии с объяснением причин отключения линтинга (см. выше) и отметки об найденном техдолге или точках ростах (комментарии `// TODO`) - если не получается сделать лучше прямо сейчас, то стоит хотя бы отметить и записать свои мысли.
Опасность: стоит следить за количеством комментариев `TODO`, если команда не уменьшает их количество и только генерирует новые, то нужно вводить инструменты контроля количества и выполнения (e.g. можно добавить ограничение, что каждый `TODO` обязан иметь ссылку на тикет на выполнения)

### Отзывчивость и понятность интерфейса

Нельзя оставлять юзера без фидбека. Если что-то происходит, юзер должен об этом знать.
Пустой экран пока что-то грузится - зло. Нужно показать хоть текстовый лоадер.
Пустой экран когда что-то упало - зло. Нужно показать хотя бы текст "Что-то пошло не так, обнови страницу"
